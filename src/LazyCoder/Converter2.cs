using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using LazyCoder.CSharp;
using LazyCoder.Typescript;
using LazyCoder.Writers;
using Microsoft.CodeAnalysis;

namespace LazyCoder
{
    public static class Converter2
    {
        public static TsFile[] Convert(Compilation compilation,
                                       IEnumerable<ICoder> coders,
                                       ICoder defaultCoder = null,
                                       IEnumerable<ICustomTypeConverter> customTypeConverters =
                                           null)
        {
            if (customTypeConverters != null)
            {
                TsType.RegisterCustomTypeConverters(customTypeConverters);
            }

            var csDeclarations = CsDeclarationFactory2.Create(compilation).ToArray();

            var writtenTsFiles = coders.SelectMany(coder => coder.Rewrite(csDeclarations))
                                       .Where(x => x.Declarations.Any())
                                       .ToArray();

            return FixBuild(writtenTsFiles,
                            defaultCoder ?? new DefaultCoder(),
                            csDeclarations,
                            compilation);
        }

        // todo same folder different case
        public static string WriteFile(string outputDirectory,
                                       TsFile tsFile)
        {
            var directory = string.IsNullOrEmpty(tsFile.Directory) || tsFile.Directory == "."
                                ? Path.GetFullPath(outputDirectory)
                                : Path.Combine(Path.GetFullPath(outputDirectory), tsFile.Directory);
            Directory.CreateDirectory(directory);
            var content = WriteFileToString(tsFile);
            var filePath = Path.Combine(directory, tsFile.Name + ".ts");
            File.WriteAllText(filePath, content);
            return filePath;
        }

        public static string WriteFileToString(TsFile tsFile)
        {
            var writerContext = new WriterContext();
            writerContext.Write(tsFile);
            return writerContext.GetResult();
        }

        private static TsFile[] FixBuild(TsFile[] tsFiles,
                                         ICoder defaultCoder,
                                         CsDeclaration[] csDeclarations,
                                         Compilation compilation)
        {
            var exportRegistry = new ExportRegistry();

            foreach (var tsFile in tsFiles)
            {
                exportRegistry.Register(tsFile);
            }

            var generatedFiles = new List<TsFile>();
            var filesToFix = new Stack<TsFile>(tsFiles);
            while (filesToFix.Count > 0)
            {
                var fileToFix = filesToFix.Pop();

                // 1. Generating and auto importing external types
                var externals = FindExternals(fileToFix);
                foreach (var csType in externals)
                {
                    if (!exportRegistry.TryGetExport(csType, out var export))
                    {
                        Generate(csType);

                        if (!exportRegistry.TryGetExport(csType, out export))
                        {
                            throw new Exception($"Can not find Export for {csType}");
                        }
                    }

                    if (export.TsFile != fileToFix)
                    {
                        AutoImport(fileToFix, export);
                    }
                }

                // 2. Generating derived types
                var derivedTypes = FindDerivedTypes(externals, csDeclarations);
                foreach (var csType in derivedTypes)
                {
                    if (!exportRegistry.TryGetExport(csType, out _))
                    {
                        Generate(csType);
                    }
                }
            }

            void Generate(CsType csType)
            {
                var csDeclaration = CsDeclarationFactory2.Create(compilation, csType.TypeSymbol);
                var autoGeneratedTsFiles = defaultCoder.Rewrite(new[]
                                                                {
                                                                    csDeclaration
                                                                });
                foreach (var autoGeneratedTsFile in autoGeneratedTsFiles)
                {
                    exportRegistry.Register(autoGeneratedTsFile);
                    filesToFix.Push(autoGeneratedTsFile);
                    generatedFiles.Add(autoGeneratedTsFile);
                }
            }

            return tsFiles.Concat(generatedFiles).ToArray();
        }

        private static void AutoImport(TsFile tsFile, Export export)
        {
            var tsImport = new TsImport
                           {
                               Named = new[]
                                       {
                                           export.Name
                                       },
                               Path = Helpers.GetPathFromAToB(DirectoryToPath(tsFile.Directory),
                                                              DirectoryToPath(export
                                                                              .TsFile.Directory))
                                      + "/" + export.Name
                           };
            tsFile.Import(tsImport);
        }

        private static CsType[] FindExternals(TsFile tsFile)
        {
            return tsFile.Declarations
                         .SelectMany(DependencyFinder.Find)
                         .ToArray();
        }

        private static CsType[] FindDerivedTypes(CsType[] csTypes, CsDeclaration[] csDeclarations)
        {
            return csTypes.SelectMany(x => csDeclarations
                                           .Select(y => y.CsType)
                                           .Where(y => x != y &&
                                                       x.OriginalType
                                                        .IsAssignableFrom(y.OriginalType)))
                          .ToArray();
        }

        private static string[] DirectoryToPath(string directory)
        {
            return string.IsNullOrEmpty(directory) || directory == "."
                       ? Array.Empty<string>()
                       : directory.Split(Path.DirectorySeparatorChar);
        }

        private class ExportRegistry
        {
            private readonly Dictionary<CsType, Export> exports =
                new Dictionary<CsType, Export>();

            public void Register(TsFile tsFile)
            {
                foreach (var tsDeclaration in tsFile.Declarations)
                {
                    Register(tsFile, tsDeclaration);
                }
            }

            public bool TryGetExport(CsType csType, out Export export)
            {
                return exports.TryGetValue(csType, out export);
            }

            private void Register(TsFile tsFile, TsDeclaration tsDeclaration)
            {
                switch (tsDeclaration)
                {
                    case TsClass _:
                    case TsInterface _:
                    case TsEnum _:
                        Add(new Export(tsDeclaration, tsFile));
                        break;
                    case TsFunction _:
                        break;
                    case TsNamespace tsNamespace:
                        foreach (var declaration in tsNamespace.Declarations)
                        {
                            Register(tsFile, declaration);
                        }

                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(tsDeclaration),
                                                              tsDeclaration.GetType().Name,
                                                              null);
                }
            }

            private void Add(Export export)
            {
                if (export.CsType != null && !exports.ContainsKey(export.CsType))
                {
                    exports.Add(export.CsType, export);
                }
            }
        }

        private class Export
        {
            public Export(TsDeclaration tsDeclaration, TsFile tsFile)
            {
                CsType = tsDeclaration.CsType;
                Name = tsDeclaration.Name;
                TsFile = tsFile;
            }

            public CsType CsType { get; }
            public string Name { get; }
            public TsFile TsFile { get; }
        }
    }
}